{% extends "base.html.twig" %}

{% block title %} Metrics analys {% endblock %}

{% block body %}

    <div class="container my-5">
        <h1 class="display-4">Analys av kodkvalitetsmått</h1>
        <hr class="my-4">
        <div class="row my-5">
            <div class="col-sm-4">
                <div class="list-group">
                    <a href="#introduktion" class="list-group-item list-group-item-action active" aria-current="true">
                    Introduktion
                    </a>
                    <a href="#kmom02" class="list-group-item list-group-item-action">Kmom02</a>
                    <a href="#kmom03" class="list-group-item list-group-item-action">Kmom03</a>
                    <a href="#kmom04" class="list-group-item list-group-item-action">Kmom04</a>
                    <a href="#kmom05" class="list-group-item list-group-item-action">Kmom05</a>
                    <a href="#kmom06" class="list-group-item list-group-item-action">Kmom06</a>
                </div>
            </div>
            <div class="col-sm-8">
                <h2 id="introduktion">1. Introduktion</h2>
                <h4>1.1 Kvalitetsmått 6C</h4>
                <h5>1.1.1 Codestyle</h5>
                <p>Codestyle är en uppsättning regler eller riktlinjer som är specifika för olika programmeringsspråk t.ex. för att visa ett kodblock i Python används indrag, medan i JavaScript används klammerparenteser <code>&lcub;&rcub;</code>. Det finns dock flera element som är gemensamma för ett stort antal programmeringsstilar. Att följa regler och riktlinjer för kodstil är viktigt för att uppnå god kodläsbarhet.</p>
                <p>I mitt Symfony-projekt används tre utvecklingsverktyg för att hjälpa mig att förbättra min kodningsstil och uppnå renare kod. Dessa verktyg är PHP Coding Standards Fixer, PHPMD och PHPStan. PHPMD och PHPStan fungerar enligt en regeluppsättning &#40;<code>.me/report/phpmd.xml och me/report/phpstan.neon</code>&#41; som kontrollerar att min kod följer reglerna. Alla verktyg som nämns ovan installerats lokalt i mappen <code>me/report/tools</code>. För att kunna enkelt exekvera dessa verktyg från terminalen, har jag inkluderat skripten i <code>me/report/composer.json</code>
                <pre><code>
                    "scripts": {
                        "csfix": "tools/php-cs-fixer/vendor/bin/php-cs-fixer fix src",
                        "phpmd": "tools/phpmd/vendor/bin/phpmd . text phpmd.xml || true",
                        "phpstan": "tools/phpstan/vendor/bin/phpstan || true",
                        "lint": [
                            "@phpmd",
                            "@phpstan",
                            "@csfix"
                        ]
                    }</code></pre></p>
                <h5>1.1.2 Coverage</h5>
                <p>Kodtäckning är ett mått som ger en uppskattning av hur många rader, filer, klasser, metoder som omfattas av ett eller flera testfall. En högre täckningsgrad indikerar en vältestad kod, medan en låg täckningsgrad kan innebära potentiella risker inom kvalitetssäkringen.</p>
                <p>För att kunna skriva testfall och därmed testa klasser i projekttet har jag integrerat verktyget PHPUnit samt genererat Kodtäckning rapport som HTML fil. Rapporten ligger i <code>me/report/docs/coverage</code>
                <figure>
                    <a href="{{ asset('img/code_coverage.png') }}" target="_blank">
                        <img src="{{ asset('img/code_coverage.png') }}" alt="Code coverage Game" width="500" height="600">
                    </a>
                    <figcaption>Kodtäckning me/report/src/Game.</figcaption>
                </figure>
                </p>
                <h5>1.1.3 Complexity</h5>
                <p>Complexity eller Conditional Complexity är ett mått som mäter komplexiteten hos en kodbas genom att analysera kontrollflödet för ett program. Det ger insikter i antalet oberoende sökvägar inom ett programs källkod och hjälper till att bedöma dess läsbarhet, underhållbarhet och testbarhet. Konceptet bakom cyklomatisk komplexitet bygger på idén att ju fler beslutspunkter, såsom villkor &#40;if-satser, switch-satser&#41; och loopar, en kodbit har, desto mer komplex blir den.</p>
                <p>Genom att analysera kodens cyklomatiska komplexitet kan vi identifiera komplexa områden som kan kräva omfaktorisering eller ytterligare testning för att förbättra kodkvaliteten och minska sannolikheten för buggar.</p>
                <p>På bilden nedan visas en översikt av maintainability/complexity av min kod genererat av PhpMetrics. Varje fil symboliseras av en cirkel. Cirkelns storlek representerar den cyklomatiska komplexiteten. Färgen på cirkeln representerar Maintainability Index. Stora röda cirklar kommer förmodligen att vara svåra att underhålla.
                <figure>
                    <img src="{{ asset('img/complexity.png') }}" alt="Complexity of my Symfony project generated by PhpMetrics" width="100" height="100">
                    <figcaption>Komplexiteten i mitt Symfony-projekt genererat av PhpMetrics.</figcaption>
                </figure>

                <figure>
                    <a href="{{ asset('img/biggest_complexity.png') }}" target="_blank"><img src="{{ asset('img/biggest_complexity.png') }}" alt="Classes with the greatest complexity" width="800"></a>
                    <figcaption>Klasser i mitt Symfony-projekt med störst komplexitet enligt PhpMetrics.</figcaption>
                </figure>

                <figure>
                    <a href="{{ asset('img/complexity_scrutinazer.png') }}" target="_blank"><img src="{{ asset('img/complexity_scrutinazer.png') }}" alt="Classes with the greatest complexity" width="800"></a>
                    <figcaption>Klasser i mitt Symfony-projekt med störst komplexitet enligt Scrutinazer.</figcaption>
                </figure>
                </p>
                <h5>1.1.4 Cohesion aka Lack of coheison of methods &#40;LCOM&#41;</h5>
                <p>Cohesion är ett mått som bedömer sambandet mellan metoder i en klass, nämligen hur väl metoder passar ihop i klassen.</p>
                <p>Termen cohesion brukar beskrivas som antingen "high cohesion" eller "low cohesion". Klasser med "high cohesion" anses vara mer önskvärda eftersom detta attribut är kopplat till flera positiva egenskaper hos programvara, såsom robusthet, pålitlighet, återanvändbarhet och läsbarhet. Å andra sidan är "low cohesion" associerat med oönskade egenskaper som gör koden svår att underhålla, testa, återanvända eller till och med förstå.</p>
                <p>Som programmerare bör man sträva efter att uppnå lägre värden i måttet Lack of coheison of methods &#40;LCOM&#41;, eftersom "high cohesion" överensstämmer med principen om ett enda ansvar.</p>
                <p>I mitt fall beräknar PhpMetrics det genomsnittliga LCOM-värdet till <code>1.52</code>, och nedan visas en bild där klasser listas i en fallande ordning baserat på LCOM.
                    <figure>
                        <a href="{{ asset('img/lcom.png') }}" target="_blank"><img src="{{ asset('img/lcom.png') }}" alt="The Lack of coheison of methods" width="800"></a>
                        <figcaption>Klasserna rangordnas i en fallande ordning baserat på LCOM, där lägre värden indikerar bättre resultat.</figcaption>
                    </figure>
                </p>
                <h5>1.1.5 Coupling</h5>
                <p>Coupling avser hur mycket moduler eller klasser är beroende av varandra. Det mäter i princip hur nära sammankopplade två moduler eller klasser är och hur starka relationer de har.</p>
                <p>Rapporten som genererats av PhpMetrics belyser två mätvärden: Afferent coupling &#40;AC&#41; och Efferent coupling &#40;EC&#41;. Afferent koppling &#40;AC&#41; är antalet klasser som påverkas av en given klass så kallade utåtriktade kopplingar. Efferent koppling &#40;EC&#41; är antalet klasser från vilka en given klass tar emot effekter så kallade inkommande kopplingar. Ett högt antal AC &#40;utåtriktade&#41; kopplingar kan indikera att denna klass använder många andra klasser. Ett högt antal EC &#40;inkommande&#41; kopplingar kan indikera att många andra klasser är beroende av denna klass.</p>
                <p>Låg koppling, vilket betyder få eller inga beroenden till andra klasser, anses ofta vara ett tecken på välskriven kod och bra design. När detta kombineras med hög kohesion &#40;coheison&#41; främjar det kod med hög läsbarhet och underhållbarhet.
                <figure>
                        <a href="{{ asset('img/coupling.png') }}" target="_blank"><img src="{{ asset('img/coupling.png') }}" alt="An overview of all the classes in my Symfony project showing their AC and EC connection" width="800"></a>
                        <figcaption>En översikt över alla klasser i mitt Symfony-projekt som visar deras AC- och EC-koppling.</figcaption>
                    </figure>
                </p>

                <p>Jag spenderade mer tid på guiden <a href="https://dbwebb.se/guide/kom-igang-med-objektorienterad-programmering-i-php">Kom igång med Objektorienterad programmering i PHP. Jag tycker att det var givande att koda tillsammans med guiden.</a></p>
                <h4>Vilken är din TIL för detta kmom?</h4>
                <p>Väldigt mycket som var  nytt i denna kmom. Jag lärt mig mer om nampespace, klasse och objekter i PHP, DocBlock kommentarer, privata och publika metoder och variabler, autoloading.</p>
                <h2 id="kmom02">Kmom02</h2>
                <h4>Förklara kort de objektorienterade konstruktionerna arv, komposition, interface och trait och hur de används i PHP.</h4>
                <p>Arv kan förkralas som en relation mellan klasserna av typ är-en. Till exempel klass VovloBil kan ärva från klass Bil, alltså att klassen VovloBil kan ärva metoder och egenskaper som tillhör klassen Bill. Till exempel metoden kör och egenskap som t.ex. har fyra hjul.</p>
                <p>Komposition kan förklaras som en relation mellan klasserna av typen har-en dvs att en klass kan ha en annan klass som en medlemsvariabel. Till exempel klass Kortlek kan ha klass Kort som en medlemsvariabel.</p>
                <p>Trait liknar en klass genom att den kan definiera metoder, men till skillnad från en klass kan den inte instansieras på egen hand. Istället är trait avsedd att inkluderas i en klass med hjälp av "use"-satsen. När trait används i en klass blir de metoder som definieras i trait en del av klassens publika gränssnitt. Trait är användbar i situationer när man behöver dela funktionalitet mellan flera klasser, men man inte vill skapa en hierarki av arv som kan bli svårhanterlig eller oflexibel.</p>
                <p>Interface är ett kontrakt där en klass lovar att erbjuda en viss uppsättning metoder. En klass kan implementera ett interface, det innebär att klassen förbinder sig att erbjuda ett API som motsvaras av interfacet.Ett interface innehåller ingen kod som en klass kan återanvända, det är bara ett löfte om att interfacets metoder skall återfinnas inuti klassen.När man vet att en klass implementerar ett visst interface så vet man också vad man kan göra med den klassen. Interface i PHP liknar abstrakta klasser i Python.</p>
                <h4>Berätta om din implementation från uppgiften. Hur löste du uppgiften, är du nöjd/missnöjd, vilken förbättringspotential ser du i din koden och dina klasser?</h4>
                <p>För att visa kort i sidan använder jag en sprite sheet. I klassen CardGraphic när jag skapar ett kort beräknas det även en offset alltså en position på sprite sheet där motsvarande kort ritas. Jag skapar kortlek med hjälp av en nästlad loop där jag loopar igenom två arrayer, den ena med namn på suits och den andra namn på ranks. Deck är en array som fylls med 52 st CardGraphic objekt. I mina routes skickar jag $data arrayen fylld med objekt som deck och hand. Därefter anropar jag olika medtoder inuti twig tamplaten och visar upp resultat. Förstår inte riktigt varför, men jag var tvungen att instansiera Deck och Hand klasser i varenda route eftersom instanserna/objekt av någon anledning inte ville sparas i sessionen.</p>
                <p>Som förbättringspotential ser jag att en hel del av kod som används i rotes kan skrivas om till separata funktioner.</p>
                <h4>Berätta hur det kändes att modellera ett kortspel med flödesdiagram och psuedokod. Var det något som du tror stödjer dig i din problemlösning och tankearbete för att strukturera koden kring en applikation?</h4>
                <p>Jag har svårt att svara på denna fråga eftersom jag skapade klasser innan jag ritade UML till mina klasser. Jag utgick väldigt mycket från den exempel som vi fick av Mikael till denna kmom.</p>
                <h4>Vilken är din TIL för detta kmom?</h4>
                <p>Jag lärt mig hur man skriver en konstruktor <code>__construct()</code> i PHP samt att man anropar metoder med en pil <code>-></code>. För att ärva metoder och egenskaper från en annan klass skall man använda konstruktion <code>parent::__construct($rank, $suit);</code> och även skicka in argument/parametrar. Jag lärt mig att för att kunna arbeta med session och POST metoden i Symfony måste man ange <code>use Symfony\Component\HttpFoundation\Request;
use och Symfony\Component\HttpFoundation\Session\SessionInterface;</code></p>
                <h2 id="kmom03">Kmom03</h2>
                <h4>Berätta hur det kändes att modellera ett kortspel med flödesdiagram och psuedokod. Var det något som du tror stödjer dig i din problemlösning och tankearbete för att strukturera koden kring en applikation?</h4>
                <p>Som utgångspunkt i modelleringen tog jag <a href="https://dbwebb.se/uppgift/bygg-kortspel-i-php-och-symfony-enligt-mvc#kortspel" target="_blank">rekomendationer</a> till kmom03 "En spelrunda kan se ut så här när en spelare spelar mot banken." Jag fick undersöka vilka klasser som är "typiska" för kortspel. Föregående kmom02 har get mig en bra grund för att jag skulle kunna utveckla och bygga på den basen och de kalsser som jag skapade under kmom02. Det flödesschema som jag visar i sidan med dokumentation representerar spelflödet mellan spelare och bank och psuedokoden visar hur jag tänker räkna ut handens värde.</p>
                <h4>Berätta om din implementation från uppgiften. Hur löste du uppgiften, är du nöjd/missnöjd, vilken förbättringspotential ser du i din koden, dina klasser och applikationen som helhet?</h4>
                <p>I routen <code>#[Route('/game/init', name: 'game_init_post', methods: ['POST'])]</code> instantieras Game klassen som i sin tur instansierar spelare, bank och kortlek. Därefter anropas Game klassens metod <code>start</code> som blandar kortleken. All data sparas i session.</p>
                <p>Användaren presenteras med fyra alternativ (en form med fyra knappar) som i sin tur exekverar logiken/metoder. Jag återanvänder Mikaels <code>flash.html.twig</code> fil i kombination med Symfonys inbyggd <code>addFlash()</code> metod för att kunna informera användaren om resultatet av spelet. Jag valde att hålla mig till principen KISS och är rätt så nöjd med resultatet.</p>
                <h4>Vilken är din känsla för att koda i ett ramverk som Symfony, så här långt in i kursen?</h4>
                <p>Det känns som om jag fått grepp om hur routes, klasser och session kan samspela i Symfony ramverket för att få en fungerande applikation.</p>
                <h4>Vilken är din TIL för detta kmom?</h4>
                <p>Jag har lärt mig om vilka arbetssätt kan hjälpa mig att strukturera upp programkod när jag bygger program och applikationer.</p>
                <p>Flowchart eller flödesdiagram är nyttiga då man behöver bygga förståelse för hur en process eller ett arbetsflöde skall gå till. Exempelvis kan vi visualisera hur en splerunda mellan spelare och bank kan gå till.</p>
                <p>Pseudokod är till för att beskriva algoritmer med "vanligt" språk, vilket gör det möjligt att fokusera på algoritmens logik.</p>
                <p>Jag har lärt mig grunderna i hur PHP-dokumentation ska se ut.</p>
                <h2 id="kmom04">Kmom04</h2>
                <h4>Berätta hur du upplevde att skriva kod som testar annan kod med PHPUnit och hur du upplever phpunit rent allmänt.</h4>
                <p>Jag har dragit slutsatsen att för att skriva kod som är lätt att testa måste man ha det i åtanke när man skriver kod. Det har varit svårt i vissa fall att bli av med beroenden då jag använder klasser inne i klasser som medlemmar/egenskaper och då har det varit svårt att skriva kod för testklasser. Till exempel, för att testa klassen Game, var jag tvungen att skriva om __construct-metod. Jag skrev om konstruktorn för att den skulle ta emot spelar- och bankklasser för att möjligtgöra att testklasser skall kunna ta emot mockade klasser.</p>
                <p>Jag upplever att dokumentationen till PHPUnit är inte så enkel att förstå. Det som var inte så enkelt var att förstå hur metoder <code>createMock</code> och <code>getMockBuilder</code> fungerar.</p>
                <p>Jag tycker att det är trevligt med visualisering av kodtäckning de testade klasser. Man ser tydligt vilka rader/metoder som täcks av testfall i en testsuit.</p>
                <h4>Hur väl lyckades du med kodtäckningen av din kod, lyckades du nå mer än 90% kodtäckning?</h4>
                <p>Jag har lyckats att täcka 96.74% av rader, 94.29% av funktioner/metoder och 66.67% av classes och traits.</p>
                <h4>Upplever du din egen kod som “testbar kod” eller finns det delar i koden som är mer eller mindre testbar och finns det saker som kan göras för att förbättra kodens testbarhet? Valde du att skriva om delar av din kod för att förbättra den eller göra den mer testbar, om så berätta lite hur du tänkte.</h4>
                <p>De delar som var svåra att testa var delar med beroenden. Till exempel, för att testa metod <code>play</code> av <code>Game</code> klassen var jag tvungen att mocka <code>Bank</code> klass och dess <code>hit metod</code> samt <code>Hand</code> klass med tillhörade metod <code>getValue</code>.</p>
                <h4>Fundera över om du anser att testbar kod är något som kan identifiera “snygg och ren kod”.</h4>
                <p>Testbar kod är kod som är strukturerad på ett sätt som är lätt att förstå och som separerar olika delar av funktionaliteten i separata moduler som kan testas oberoende.  Med det sagt tycker jag att testbar kod bidrar till att kod kan betraktas som “snygg och ren kod”.</p>
                <h4>Vilken är din TIL för detta kmom?</h4>
                <p>Jag lärt mig hur jag kan använda verktyget <code>PHPUnit</code> för att skriva test suits och testfall för egendefinierade klasser. Jag lärt mig hur jag kan mocka objekt och metoder.</p>
                <p>Jag lärt mig att dokumentera min kod med hjälp av DocBlock och generera  HTML dokumentation med hjälp av phpDocumentor.</p>
                <p>Redovisning</p>
                <h2 id="kmom05">Kmom05</h2>
                <h4>Gick det bra att jobba igenom övningen med Symfony och Doctrine. Något särskilt du tänkte/reagerade på under övningen?</h4>
                <p>Det gick bra. Jag försökte finna skillnader mellan Book entity och Book repository, och komm fram till att Book entity eller Book class representerar en tabel i en databas. För att skapa en Entity Class används komandot <code>php bin/console make:entity</code>. Här anger vi även namn till tabelens columner samt dess datatyp. Book repository är ett 'service' class som ett mellan lager som skriver och läser objekt av Entity (Book) klassen till databasen.</p>
                <p>När vi gör ändringar i databasens schema dvs ändrar namn på kolumner eller dess datatyper måste vi skapa en migration. Vi skapar en migration med komandot <code>php bin/console make:migration</code> och updaterar eller nedgraderar version av vår databas med komandot <code>php bin/console doctrine:migrations:migrate</code></p>
                <p>För att kunna visa upp data ur databas måste vi skapa en kontroller med komandot <code>php bin/console make:controller ControllerName</code></p>
                <h4>Berätta om din applikation och hur du tänkte när du byggde upp den. Tänkte du något speciellt på användargränssnittet?</h4>
                <p>Användargränssnit i min applikation är mycket enkelt. Jag tog inspiration till gränssnitet från kursen databas v2. Jag lade till länkar som möjligtgör att radera och updatera böcker i min bibliotek. Länkarna dirigerar användaren om till en sida med en formulär.</p>
                <h4>Gick det bra att jobba med ORM i CRUD eller vad anser du om det, jämför gärna med andra sätt att jobba med databaser?</h4>
                <p>Det gick bra. Exemplet som vi fick till övningen symfony-doctrine var i stort sätt en lösning till CRUD uppgifterna. Det är nog samma steg oavsätt om man för in ändringar i databas via PHP och classer som rent SQL. I PHP ORM använder vi metoder som set och get likaså i SQL används nyckelord SET och SELECT eller WHERE.</p>
                <h4>Vad är din uppfattning om ORM så här långt och relatera gärna till andra sätt att jobba med applikationskod mot databaser?</h4>
                <p>ORM är en teknik som används för att hantera kommunikationen mellan en applikationskod och en databas. ORM erbjuder en abstraktionsnivå genom att mappa objekt i kodbasen till rader i en relationsdatabas och vice versa. Genom att använda ORM kan vi interagera med databaser genom att använda objekt och deras metoder istället för att skriva rå SQL-kod.</p>
                <h4>Vilken är din TIL för detta kmom?</h4>
                <p>Jag har lärt mig hur jag kan integrera en databas i mitt Symfony projekt med hjälp av ramverk Doctrine ORM.
                </p>
                <h2 id="kmom06">Kmom06</h2>
                <p>Redovisning</p>
            </div>
        </div>
    </div>

{% endblock %}